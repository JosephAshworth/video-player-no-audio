<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Silent Video Player</title>
  <style>
    :root { color-scheme: light dark; }
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif; margin: 0; padding: 24px; }
    h1 { font-size: 20px; margin: 0 0 12px; }
    .controls { display: flex; gap: 12px; align-items: center; flex-wrap: wrap; margin-bottom: 16px; }
    .hint { font-size: 12px; opacity: .7; }
    video { width: 100%; max-height: 70vh; background: #000; border-radius: 8px; }
    .dropzone { border: 2px dashed currentColor; border-radius: 8px; padding: 16px; text-align: center; opacity: .8; }
    .dropzone.dragover { opacity: 1; border-style: solid; }
    button { padding: 8px 12px; border-radius: 6px; border: 1px solid currentColor; background: transparent; cursor: pointer; }
    .player-controls { display: flex; gap: 12px; align-items: center; margin-top: 12px; }
    .time { font-variant-numeric: tabular-nums; font-size: 12px; opacity: .8; }
    input[type="range"] { width: min(600px, 60vw); }
  </style>
</head>
<body>
  <h1>Silent Video Player</h1>

  <div class="controls">
    <input id="fileInput" type="file" accept="video/*">
    <button id="clearBtn" type="button" aria-label="Clear video">Clear</button>
    <span class="hint">Pick a video file. It will play with no audio.</span>
  </div>

  <div id="recentFiles" style="margin-bottom: 16px;">
    <h3 style="font-size: 14px; margin: 0 0 8px; opacity: .8;">Recent Files</h3>
    <div id="recentList" style="display: flex; gap: 8px; flex-wrap: wrap;"></div>
    <div id="noRecent" style="font-size: 12px; opacity: .6; font-style: italic;">No recent files yet</div>
  </div>

  <div id="dropzone" class="dropzone" aria-label="Drop video file here">
    Drag & drop a video file here
  </div>

  <div style="margin-top:16px;">
    <video id="player" playsinline muted preload="metadata"></video>

    <div class="player-controls" aria-label="Playback controls (volume is permanently disabled)">
      <button id="playPause" type="button">Play</button>
      <button id="restart" type="button" title="Restart">↺</button>
      <input id="seek" type="range" min="0" max="100" step="0.1" value="0" aria-label="Seek timeline">
      <span class="time" id="timeLabel">00:00 / 00:00</span>
    </div>
  </div>

  <script>
    (function () {
      const fileInput = document.getElementById('fileInput');
      const player = document.getElementById('player');
      const dropzone = document.getElementById('dropzone');
      const clearBtn = document.getElementById('clearBtn');
      const playPause = document.getElementById('playPause');
      const restart = document.getElementById('restart');
      const seek = document.getElementById('seek');
      const timeLabel = document.getElementById('timeLabel');
      const recentFiles = document.getElementById('recentFiles');
      const recentList = document.getElementById('recentList');
      const noRecent = document.getElementById('noRecent');

      let currentObjectUrl = null;
      let recentFilesList = [];
      let db = null;

      function formatTime(seconds) {
        if (!isFinite(seconds)) return '00:00';
        const s = Math.floor(seconds % 60).toString().padStart(2, '0');
        const m = Math.floor((seconds / 60) % 60).toString().padStart(2, '0');
        const h = Math.floor(seconds / 3600);
        return h > 0 ? `${h}:${m}:${s}` : `${m}:${s}`;
      }

      // IndexedDB helpers
      function openDb() {
        return new Promise((resolve, reject) => {
          const request = indexedDB.open('silent-player', 1);
          request.onupgradeneeded = (event) => {
            const database = event.target.result;
            if (!database.objectStoreNames.contains('videos')) {
              database.createObjectStore('videos', { keyPath: 'key' });
            }
          };
          request.onsuccess = () => resolve(request.result);
          request.onerror = () => reject(request.error);
        });
      }
      function idbPutBlob(key, blob) {
        return new Promise((resolve, reject) => {
          const tx = db.transaction('videos', 'readwrite');
          const store = tx.objectStore('videos');
          store.put({ key, blob });
          tx.oncomplete = () => resolve();
          tx.onerror = () => reject(tx.error);
        });
      }
      function idbGetBlob(key) {
        return new Promise((resolve, reject) => {
          const tx = db.transaction('videos', 'readonly');
          const store = tx.objectStore('videos');
          const req = store.get(key);
          req.onsuccess = () => resolve(req.result ? req.result.blob : null);
          req.onerror = () => reject(req.error);
        });
      }

      function computeKey(file) {
        return `${file.name}__${file.size}__${file.lastModified}`;
      }

      function lockVolume(videoEl) {
        videoEl.muted = true;
        videoEl.defaultMuted = true;
        try { videoEl.volume = 0; } catch (_) {}
        const disableTracks = () => {
          try {
            if (videoEl.audioTracks && videoEl.audioTracks.length) {
              for (let i = 0; i < videoEl.audioTracks.length; i++) {
                videoEl.audioTracks[i].enabled = false;
              }
            }
          } catch (_) {}
        };
        disableTracks();
        videoEl.addEventListener('loadedmetadata', disableTracks, { once: true });
        const enforce = () => {
          if (!videoEl.muted || videoEl.volume !== 0) {
            try { videoEl.volume = 0; } catch (_) {}
            videoEl.muted = true;
            videoEl.defaultMuted = true;
          }
        };
        videoEl.addEventListener('volumechange', enforce);
        videoEl.addEventListener('play', enforce);
        videoEl.addEventListener('loadeddata', enforce);
        enforce();
        try {
          Object.defineProperty(videoEl, 'volume', { configurable: false, enumerable: true, get: () => 0, set: () => {} });
        } catch (_) {}
      }

      function persistRecent() {
        try {
          localStorage.setItem('recentVideoFiles', JSON.stringify(recentFilesList));
        } catch (_) {}
      }

      function addToRecentImmediate(file) {
        const key = computeKey(file);
        const fileInfo = { key, name: file.name, size: file.size, type: file.type, lastModified: file.lastModified, hasData: false };
        recentFilesList = recentFilesList.filter(f => f.key !== key);
        recentFilesList.unshift(fileInfo);
        recentFilesList = recentFilesList.slice(0, 20);
        persistRecent();
        updateRecentUI();
      }

      function addToRecent(file) {
        const key = computeKey(file);
        const reader = new FileReader();
        reader.onload = async (e) => {
          try {
            const blob = new Blob([e.target.result], { type: file.type || 'application/octet-stream' });
            await idbPutBlob(key, blob);
            const idx = recentFilesList.findIndex(f => f.key === key);
            if (idx !== -1) {
              recentFilesList[idx].hasData = true;
              persistRecent();
              updateRecentUI();
            }
          } catch (_) {}
        };
        reader.readAsArrayBuffer(file);
      }

      function updateRecentUI() {
        recentList.innerHTML = '';
        if (!recentFilesList || recentFilesList.length === 0) {
          noRecent.style.display = 'block';
          return;
        }
        noRecent.style.display = 'none';
        recentFilesList.forEach((fileInfo) => {
          const container = document.createElement('div');
          container.style.display = 'flex';
          container.style.alignItems = 'center';
          container.style.gap = '4px';
          
          const btn = document.createElement('button');
          btn.textContent = fileInfo.name;
          btn.title = `Size: ${Math.round(fileInfo.size / 1024 / 1024 * 100) / 100} MB${fileInfo.hasData ? ' (Ready)' : ' (Loading...)'}`;
          btn.style.fontSize = '12px';
          btn.style.padding = '4px 8px';
          btn.style.maxWidth = '200px';
          btn.style.overflow = 'hidden';
          btn.style.textOverflow = 'ellipsis';
          btn.style.whiteSpace = 'nowrap';
          btn.style.opacity = fileInfo.hasData ? '1' : '0.6';
          btn.addEventListener('click', async () => {
            try {
              const blob = await idbGetBlob(fileInfo.key);
              if (blob) {
                const file = new File([blob], fileInfo.name, { type: fileInfo.type, lastModified: fileInfo.lastModified });
                loadFile(file);
              } else {
                fileInput.click();
              }
            } catch (_) {
              fileInput.click();
            }
          });
          
          const deleteBtn = document.createElement('button');
          deleteBtn.textContent = '×';
          deleteBtn.title = 'Remove from recent files';
          deleteBtn.style.fontSize = '14px';
          deleteBtn.style.padding = '2px 6px';
          deleteBtn.style.minWidth = '20px';
          deleteBtn.style.height = '20px';
          deleteBtn.style.borderRadius = '50%';
          deleteBtn.style.backgroundColor = 'transparent';
          deleteBtn.style.border = '1px solid currentColor';
          deleteBtn.style.cursor = 'pointer';
          deleteBtn.style.opacity = '0.7';
          deleteBtn.addEventListener('click', async (e) => {
            e.stopPropagation();
            try {
              // Remove from IndexedDB
              if (db) {
                const tx = db.transaction('videos', 'readwrite');
                const store = tx.objectStore('videos');
                store.delete(fileInfo.key);
              }
            } catch (_) {}
            
            // Remove from recent list
            recentFilesList = recentFilesList.filter(f => f.key !== fileInfo.key);
            persistRecent();
            updateRecentUI();
          });
          
          container.appendChild(btn);
          container.appendChild(deleteBtn);
          recentList.appendChild(container);
        });
      }

      function loadFile(file) {
        if (!file) return;
        if (!file.type.startsWith('video/')) { alert('Please select a valid video file.'); return; }
        if (currentObjectUrl) { URL.revokeObjectURL(currentObjectUrl); currentObjectUrl = null; }
        currentObjectUrl = URL.createObjectURL(file);
        player.src = currentObjectUrl;
        lockVolume(player);
        player.play().catch(() => {});
        const key = computeKey(file);
        const existingIndex = recentFilesList.findIndex(f => f.key === key);
        if (existingIndex !== -1) {
          const existingFile = recentFilesList[existingIndex];
          recentFilesList.splice(existingIndex, 1);
          recentFilesList.unshift(existingFile);
          persistRecent();
          updateRecentUI();
          if (!existingFile.hasData) { addToRecent(file); }
        } else {
          addToRecentImmediate(file);
          addToRecent(file);
        }
      }

      function handleFiles(files) { if (files && files[0]) loadFile(files[0]); }

      fileInput.addEventListener('change', (e) => handleFiles(e.target.files));

      function preventDefaults(e) { e.preventDefault(); e.stopPropagation(); }
      ['dragenter','dragover','dragleave','drop'].forEach(evt => { dropzone.addEventListener(evt, preventDefaults, false); });
      ['dragenter','dragover'].forEach(evt => { dropzone.addEventListener(evt, () => dropzone.classList.add('dragover')); });
      ['dragleave','drop'].forEach(evt => { dropzone.addEventListener(evt, () => dropzone.classList.remove('dragover')); });
      dropzone.addEventListener('drop', (e) => { const dt = e.dataTransfer; const files = dt && dt.files ? dt.files : null; handleFiles(files); });

      clearBtn.addEventListener('click', () => {
        if (currentObjectUrl) { URL.revokeObjectURL(currentObjectUrl); currentObjectUrl = null; }
        player.pause();
        player.removeAttribute('src');
        player.load();
        lockVolume(player);
        fileInput.value = '';
        timeLabel.textContent = '00:00 / 00:00';
        seek.value = '0';
        playPause.textContent = 'Play';
      });

      playPause.addEventListener('click', () => { if (!player.src) return; if (player.paused) { lockVolume(player); player.play().catch(() => {}); } else { player.pause(); } });
      restart.addEventListener('click', () => { if (!player.src) return; player.currentTime = 0; lockVolume(player); player.play().catch(() => {}); });
      seek.addEventListener('input', () => { if (!player.duration || !isFinite(player.duration)) return; const pct = Number(seek.value) / 100; player.currentTime = pct * player.duration; });
      player.addEventListener('play', () => { playPause.textContent = 'Pause'; });
      player.addEventListener('pause', () => { playPause.textContent = 'Play'; });
      const updateUi = () => { const cur = player.currentTime || 0; const dur = player.duration || 0; const pct = dur ? (cur / dur) * 100 : 0; seek.value = String(pct); timeLabel.textContent = `${formatTime(cur)} / ${formatTime(dur)}`; };
      player.addEventListener('timeupdate', updateUi);
      player.addEventListener('loadedmetadata', updateUi);

      (async function init() {
        lockVolume(player);
        try { db = await openDb(); } catch (_) { db = null; }
        try {
          const stored = JSON.parse(localStorage.getItem('recentVideoFiles') || '[]');
          if (Array.isArray(stored)) {
            // Migrate old schema if present
            recentFilesList = stored.map((f) => {
              if (f.key) return f;
              const key = `${f.name}__${f.size}__${f.lastModified}`;
              return { key, name: f.name, size: f.size, type: f.type, lastModified: f.lastModified, hasData: !!f.data };
            });
            // Drop very large lists
            recentFilesList = recentFilesList.slice(0, 20);
            persistRecent();
          }
        } catch (_) { recentFilesList = []; }
        updateRecentUI();
      })();
    })();
  </script>
</body>
</html>
